<!DOCTYPE html>
<html>
<head>
  <!-- D3 Loading -->
  <meta charset="utf-8">
  <script src="https://d3js.org/d3.v4.min.js"></script>

<style>
table {
  font-family: arial, sans-serif;
  border-collapse: collapse;
  width: 100%;
}

td, th {
  border: 1px solid #dddddd;
  text-align: left;
  padding: 8px;
}

tr:nth-child(even) {
  background-color: #dddddd;
}

.mytask {
  background-color: #ddffdd !important;
}

/* D3 styles */
svg {
  /*flex-basis: 100%;*/
  /*min-width: 400px;*/
  /*width: 100%;*/
  width: 800px;
  height: 250px;
}
.links line {
  stroke: #aaa;
}
.nodes circle {
  pointer-events: all;
}

</style>
</head>
<body>

<h1>Edge Resource Manager Demo</h1>

<h2 id='framework'></h2>

<h3> Send Commands </h3>

<form action="/start">
    <input type="submit" value="Start Tasks"/>
</form>
<!-- <br/> -->
<!-- <form action="/stop">
    <input type="submit" value="Stop Tasks"/>
</form> -->

<h3 id='numtasks'></h3>

<p id='tasks'></p>

<h3 id='numagents'></h3>
<svg></svg>
<p id='agents'></p>


<h3 id='appoutput'></h3>
<div id='predictions'>
</div>

<!-- D3 Script -->
<script>
var svg = d3.select("svg"),
    width = +svg.node().getBoundingClientRect().width,
    height = +svg.node().getBoundingClientRect().height;

// svg objects
var link, node, textElems;
// animation objects
var circles = [];
// the data - an object with nodes and links
var graph;

// load the data
d3.json("/network.json", function(error, _graph) {
  if (error) throw error;
  graph = _graph;
  initializeDisplay();
  initializeSimulation();
});



//////////// FORCE SIMULATION //////////// 

// force simulator
var simulation = d3.forceSimulation();

// set up the simulation and event to update locations after each tick
function initializeSimulation() {
  simulation.nodes(graph.nodes);
  initializeForces();
  simulation.on("tick", ticked);
}

// values for all forces
forceProperties = {
    center: {
        x: 0.5,
        y: 0.5
    },
    charge: {
        enabled: true,
        strength: -200,
        distanceMin: 1,
        distanceMax: 2000
    },
    collide: {
        enabled: true,
        strength: 1,
        iterations: 1,
        radius: 40
    },
    forceX: {
        enabled: true,
        strength: .2,
        x: .5
    },
    forceY: {
        enabled: true,
        strength: .2,
        y: .5
    },
    link: {
        enabled: true,
        distance: 50,
        iterations: 1
    }
}

// add forces to the simulation
function initializeForces() {
    // add forces and associate each with a name
    simulation
        .force("link", d3.forceLink())
        .force("charge", d3.forceManyBody())
        .force("collide", d3.forceCollide())
        .force("center", d3.forceCenter())
        .force("forceX", d3.forceX())
        .force("forceY", d3.forceY());
    // apply properties to each of the forces
    updateForces();
}

// apply new force properties
function updateForces() {
    // get each force by name and update the properties
    simulation.force("center")
        .x(width * forceProperties.center.x)
        .y(height * forceProperties.center.y);
    simulation.force("charge")
        .strength(forceProperties.charge.strength * forceProperties.charge.enabled)
        .distanceMin(forceProperties.charge.distanceMin)
        .distanceMax(forceProperties.charge.distanceMax);
    simulation.force("collide")
        .strength(forceProperties.collide.strength * forceProperties.collide.enabled)
        .radius(forceProperties.collide.radius)
        .iterations(forceProperties.collide.iterations);
    simulation.force("forceX")
        .strength(forceProperties.forceX.strength * forceProperties.forceX.enabled)
        .x(width * forceProperties.forceX.x);
    // simulation.force("forceY")
    //     .strength(forceProperties.forceY.strength * forceProperties.forceY.enabled)
    //     .y(height * forceProperties.forceY.y);
    simulation.force("link")
        .id(function(d) {return d.id;})
        .distance(forceProperties.link.distance)
        .iterations(forceProperties.link.iterations)
        .links(forceProperties.link.enabled ? graph.links : []);

    simulation.force("forceX")
        .strength(forceProperties.forceX.strength * forceProperties.forceX.enabled)
        .x(function(d) {
          if (d.group == 1) return width * forceProperties.forceX.x;
          if (d.group == 4) return -width * forceProperties.forceX.x; 
          return 0;
        });

    // updates ignored until this is run
    // restarts the simulation (important if simulation has already slowed down)
    simulation.alpha(1).restart();
}



//////////// DISPLAY ////////////

// generate the svg objects and force simulation
function initializeDisplay() {
  // set the data and properties of link lines
  link = svg.append("g")
        .attr("class", "links")
    .selectAll("line")
    .data(graph.links)
    .enter().append("line");

  circles.push(svg.append('circle').attr('cx',-10).attr('cy',-10).attr('r',5).style('fill','rgb(0,255,255)'))
  circles.push(svg.append('circle').attr('cx',-10).attr('cy',-10).attr('r',5).style('fill','rgb(0,255,255)'))
  circles.push(svg.append('circle').attr('cx',-10).attr('cy',-10).attr('r',5).style('fill','rgb(0,255,255)'))
  circles.push(svg.append('circle').attr('cx',-10).attr('cy',-10).attr('r',5).style('fill','rgb(0,255,255)'))
  circles.push(svg.append('circle').attr('cx',-10).attr('cy',-10).attr('r',5).style('fill','rgb(0,255,255)'))
  circles.push(svg.append('circle').attr('cx',-10).attr('cy',-10).attr('r',5).style('fill','rgb(0,255,255)'))
  circles.push(svg.append('circle').attr('cx',-10).attr('cy',-10).attr('r',5).style('fill','rgb(0,255,255)'))

  // set the data and properties of node circles

  var elemEnter = svg.append("g")
        .attr("class", "nodes")
    .selectAll("circle")
    .data(graph.nodes)
    .enter()

  node = elemEnter.append("circle")
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

  textElems = elemEnter.append("text")
        .attr('font-size',13)
        .text(node => node.name)

  // node tooltip
  node.append("title")
      .text(function(d) { return d.name; });
  // visualize the graph
  updateDisplay();
}

function getColorForGroup(g) {
  if (g == '1') return '#305F72';
  if (g == '2') return '#568EA6';
  if (g == '3') return '#F1D1B5';
  if (g == '4') return '#F18C8E'
  return 'orange';
}

// update the display based on the forces (but not positions)
function updateDisplay() {
    node
        .attr("r", 15)
        // .attr("stroke", forceProperties.charge.strength > 0 ? "blue" : "red")
        .attr('stroke', function(d) { return getColorForGroup(d.group)})
        .attr('fill', function(d) { return getColorForGroup(d.group)})
        // .attr("stroke-width", forceProperties.charge.enabled==false ? 0 : Math.abs(forceProperties.charge.strength)/15);

    link
        .attr("stroke-width", forceProperties.link.enabled ? 1 : .5)
        .attr("opacity", forceProperties.link.enabled ? 1 : 0);
}



// update the display positions after each simulation tick
function ticked() {
    link
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    node
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });

    textElems
        .style("text-anchor", "middle")
        .attr('dx', function(d) {return d.x;})
        .attr('dy', function(d) {return d.y - 20;})
    d3.select('#alpha_value').style('flex-basis', (simulation.alpha()*100) + '%');

    console.log('tick')
}

var cnt = 200;
var fromID = '';
var toID = '';
var startX = 0;
var startY = 0;
var endX = 0;
var endY = 0;
var circleQueue = []
function circleTick() {

  for(var i = 0; i < circleQueue.length; i++) {
    var circle = circles[i];
    var cQ = circleQueue[i];
    if(cQ.length > 0) {
      var cnt = cQ[0][0]
      if (cnt >= 100 && cQ.length > 1) {
        //there's another message waiting, pop this one!
        cQ.shift();
      }
      //we've got a message to send
      var cnt = cQ[0][0]
      var fromID = cQ[0][1]
      var toID = cQ[0][4]

      //update start and end coords
      node.attr("cx", function(d) {
        if(d.id == fromID) {
          cQ[0][2] = d.x;
          cQ[0][3] = d.y;
        } else if (d.id == toID) {
          cQ[0][5] = d.x;
          cQ[0][6] = d.y;
        }
        return d.x;
      })

      //extract update start/end coords
      var startX = cQ[0][2]
      var startY = cQ[0][3]
      var endX = cQ[0][5]
      var endY = cQ[0][6]

      //update circle location
      circle.attr('cx', Math.abs(100 - cnt) * startX / 100 + (100 - Math.abs(100 - cnt)) * endX / 100);
      circle.attr('cy', Math.abs(100 - cnt) * startY / 100 + (100 - Math.abs(100 - cnt)) * endY / 100);

      if(cnt < 100) {
        //increment the count
        cQ[0][0] += 5
      } else {
        cQ[0][2] = -10
        cQ[0][3] = -10
      }
    }
  }
}

var circleTickInterval = undefined;

function sendMessage(from, to, circleToUse) {
  while(circleQueue.length <= circleToUse) {
    //circleQueue is an array of length (# circles), each element is an array that represents a single message
    circleQueue.push([])
  }
  //add a new message to the circleQueue for this particular circle
  circleQueue[circleToUse].push([0,from,-10,-10,to,-10,-10])
  if(!circleTickInterval) {
    circleTickInterval = setInterval(circleTick, 10)
  }
}

//////////// UI EVENTS ////////////

function dragstarted(d) {
  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
}

function dragged(d) {
  d.fx = d3.event.x;
  d.fy = d3.event.y;
}

function dragended(d) {
  if (!d3.event.active) simulation.alphaTarget(0.0001);
  d.fx = null;
  d.fy = null;
}

// update size-related forces
// d3.select(window).on("resize", function(){
//     width = +svg.node().getBoundingClientRect().width;
//     height = +svg.node().getBoundingClientRect().height;
//     updateForces();
// });

// convenience function to update everything (run after UI input)
function updateAll() {
    updateForces();
    updateDisplay();
}
</script>

<script>
function loadTasks(){
  var xmlHttp = new XMLHttpRequest();
  xmlHttp.onreadystatechange = function () {
    if (xmlHttp.readyState == 4 && xmlHttp.status == 200){
      var resp = JSON.parse(xmlHttp.responseText);
      if(resp.error) {
        document.getElementById('tasks').innerHTML = resp.error.toString();
      } else {
        var tableHTML = "<table><tr><th>Task ID</th><th>Name</th><th>Agent Assigned</th><th>Framework</th><th>Type</th><th>Image</th><th>State</th></tr>"
        var cnt = 0;
        for(var i =0; i<resp.length;i++) {
          var task = resp[i];
          if ((task.state != "KILLED" && task.state != "COMPLETED") || task.name.startsWith(clientID)) {

            var tr_case = task.name.startsWith(clientID) ? '<tr class="mytask">' : "<tr>"
            var task_name = task.name
            if(task.name.startsWith(clientID)) {
              task_name = task_name.replace(clientID, "Me")
            }

            tableHTML += `${tr_case}<td>${task.taskId}</td><td>${task_name}</td><td>${task.agentId}</td><td>${task.framework.name}</td><td>${task.container.type}</td><td>${task.container.docker ? task.container.docker.image : ""}</td><td>${task.state}</td></tr>`
            cnt += 1
          }
        }
        tableHTML += "</table>"
        document.getElementById('tasks').innerHTML = tableHTML
        document.getElementById('numtasks').innerHTML = `${cnt} Tasks`
      }
    } 
  }
  xmlHttp.open("GET", '/tasks', true);
  xmlHttp.send(null);
}
loadTasks();

var clientID = 'default'
function loadID() {
  var xmlHttp = new XMLHttpRequest();
  xmlHttp.onreadystatechange = function () {
    if (xmlHttp.readyState == 4 && xmlHttp.status == 200){
      clientID = xmlHttp.responseText;
    } 
  }
  xmlHttp.open("GET", '/clientID', true);
  xmlHttp.send(null);
}
loadID();

function loadPredictions(){
  var xmlHttp = new XMLHttpRequest();
  xmlHttp.onreadystatechange = function () {
    if (xmlHttp.readyState == 4 && xmlHttp.status == 200){
      var resp = JSON.parse(xmlHttp.responseText);
      if(resp.error) {
        document.getElementById('predictions').innerHTML = ''
        document.getElementById('appoutput').innerHTML = ''
      } else if(resp.length < 0) {
        document.getElementById('appoutput').innerHTML = 'Latest Camera Frame Prediction'
        document.getElementById('predictions').innerHTML = 'not ready yet'
      } else {
        document.getElementById('appoutput').innerHTML = 'Latest Camera Frame Prediction'
        var tableHTML = "<table><tr><th>Prediction</th><th>Confidence</th></tr>"
        var cnt = 0;
        for(var i =0; i<resp[0].objects.length;i++) {
          var prediction = resp[0].objects[i];
            tableHTML += `<tr><td>${prediction.name}</td><td>${prediction.confidence}</td></tr>`
        }
        tableHTML += "</table>"
        document.getElementById('predictions').innerHTML = resp[0].objects.length > 0 ? tableHTML : ''
        document.getElementById('predictions').innerHTML += `<img src="http://conixdb.com:3003/${clientID}-predictions.jpg" alt="Latest image" height="300">`
      }
    } 
  }
  xmlHttp.open("GET", '/predictions', true);
  xmlHttp.send(null);
}
loadPredictions();

function loadFramework() {
  var xmlHttp = new XMLHttpRequest();
  xmlHttp.onreadystatechange = function () {
    if (xmlHttp.readyState == 4 && xmlHttp.status == 200){
      var resp = JSON.parse(xmlHttp.responseText);
      if(resp.error) {
        document.getElementById('framework').innerHTML = resp.error.toString();
      } else {
        document.getElementById('framework').innerHTML = `Framework: ${resp.framework.name}`
      }
    } 
  }
  xmlHttp.open("GET", '/framework', true);
  xmlHttp.send(null);
}
loadFramework();

var lastPing = {};

function loadAgents() {
  var xmlHttp = new XMLHttpRequest();
  xmlHttp.onreadystatechange = function () {
    if (xmlHttp.readyState == 4 && xmlHttp.status == 200){
      var resp = JSON.parse(xmlHttp.responseText);
      if(resp.error) {
        document.getElementById('agents').innerHTML = resp.error.toString();
      } else {
        var tableHTML = "<table><tr><th>Agent ID</th><th>Name</th><th>Last Ping</th></tr>"
        for(var i =0; i<resp.length;i++) {
          var agent = resp[i];
          tableHTML += `<tr><td>${agent.id}</td><td>${agent.name}</td><td>${agent.lastPing}</td></tr>`

          //check if there's a new ping
          if (lastPing[agent.id] != agent.lastPing) {
            lastPing[agent.id] = agent.lastPing;
            sendMessage(agent.id, "Master", i+1); //circle 0 is reserved for client => master => client
          }
        }
        tableHTML += "</table>"
        document.getElementById('agents').innerHTML = tableHTML
        document.getElementById('numagents').innerHTML = `${resp.length} Agents`
      }
    } 
  }
  xmlHttp.open("GET", '/agents', true);
  xmlHttp.send(null);
}
loadAgents();

setInterval(function() {
  sendMessage("Me", "Framework", 0);
  sendMessage("Framework", "Master", 0);
  sendMessage("Master", "Framework", 0);
  sendMessage("Framework", "Me", 0);
  loadAgents()
  loadPredictions()
  loadTasks()
}, 1000)
</script>

</body>
</html>

